{"name":"javascript","text":"# Javascript in 2018\n## Why Representer?\n\nThere are already many static site generators in the wild, even modular ones with React like [https://github.com/gatsbyjs/gatsby](Gatsby), so my idea wasn't too original. But I had my reasons:\n\n**1**. I needed some project to properly learn ES6 and beyond along with the whole bunch of react-boilerplate tech. Project had to be somewhat complex, but not too much, so I could complete it in a reasonable amount of time.\n**2**. I needed some JS code to show off. Not just a bunch of forks, but something sane.\n**3**. It had to be useful to me.\n\nSo, Representer was a good choice. What's with the name? Well, it represents me as a programmer - both like a technical blog and a JS showcase.\n\nIt also not just a regular static site generator, but also uses Web Sockets to receive Markdown text from your editor:\n![gif](hello-github.gif)\n...and can be mounted on arbitrary URL, since I have Sedent support URL on the root of my Github Pages and didn't want to bother with AppStore submissions to change it.\n\nBefore we dive into the code, I'd like to mention that Markdown isn't fully supported and conventional. I'm adding components on the go as I write this text and it might won't be Markdown at all in the end: \n\n**1**. I don't really like how Markdown handles newlines - I just hate to write two spaces at the end to get a new line. Not only because it is tedious, but also because the rendered text on web looks different than in the editor.\n**2**. I might add a few custom components in the future, extending the syntax.\n\n## Redirects\nSo, redirects are handled using `http-equiv` property, which instantly redirects to the entry point with a post name as a GET parameter and then React Router points to the actual page: \n```javascript\n// src/converter.js\n// ...\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n  <head>\n    <title>Representer</title>\n    <meta http-equiv=\"refresh\" content=\"0;URL='/${mountPoint}/?post=${postName}'\" />\n  </head>\n</html>\n// ...\n```\n```javascript\n// app/containers/HomePage/index.js\n// ...\n  render() {\n    const match = window.location.search.match(/(?:post)=([^&]*)/);\n    const posts = this.props.posts.data;\n    return (\n      <div>\n        {match ? <Redirect to={`/${config.mountPoint}/posts/${match[1]}`}/> : ''}\n        {posts ? <PostsList posts={posts}/> : ''}\n      </div>\n    );\n  }\n// ...\n```\nThere are two things I'm concerned with:\n\n**1**. I don't care about the SEO in this particular case as I don't really want it to be in the search results, but I believe this blog looses some Page Rank after redirect and search engine crawler might be confused with the whole JS execution business. Pages also don't have a `meta description`, but that could be implemented easily by supplying stripped text both to the redirect HTML template and to React component.\n\n**2**. Some of us don't really like Javascript in the browser and might have it turned off or even use browsers like w3m. Actually, I was one of those guys until I got tired managing uMatrix and such. So, I would better off using Javascript for redirect purposes and pass the text to the HTML template - JS guys could get the whole fancy stuff and those who prefer pure, unevaluated web could get the text.\n\n# Converter\nThere are few obstacles in mastering Javascript:\n**1**. Unobvious type casts. Things like `[] + []`, `{} + []` and so forth. Languages with stronger type systems like Ruby handle such cases in a more predictable manner, but I'm not a fan of duck typing anyway and nowadays, thankfully, we have things like Flow and Typescript.\n**2**. Asynchronous programming. There are too many ways to write async code and it might be confusing. You can write Pyramids of Doom using callbacks, slightly less horrible pyramids using nested promises, use async/await or generators.\n**3**. Context binding (`this` keyword). This is not an issue if you are using arrow functions. But you can't use arrow functions with async/await and generators, since they hold internal state and require the context.\n\nIn this part I will focus on the last two points. I wasn't too much exposed to async JS programming since I was using Ruby for backend programming and on the frontend usually there isn't that of a much async behaviour besides API calls, so promise chains tend to be small.\n\nIn the very first iteration of Converter programming I made it synchronous. It's job is very simple: read and copy files back and forth, create and delete. Essentially there was no need to use async operations whatsoever - performance hits the wall of IO operations anyway and the fact that synchronous operations doesn't block the main thread won't make any difference.\n\nSo, my only job was to learn how to handle async operations in 2018. First, I tried promises and generators with main generator wrapped into [https://github.com/tj/co](co):\n\n```javascript\nconst errHandler = (err) => {\n  // eslint-disable-next-line no-console\n  console.log(err.stack);\n  throw new Error(err);\n};\n\nclass Converter {\n  constructor(input, output) {\n    this.input = input;\n    this.output = output;\n  }\n\n  convert() {\n    return co(() => this.main()).catch(errHandler);\n  }\n\n  * main() {\n    const names = yield this.names(this.input);\n    const texts = yield this.texts(names);\n    const namesWithoutExtension = names.map(withoutExtension);\n    yield this.clean();\n    yield this.writeDirs(namesWithoutExtension);\n    yield this.writePosts(posts(namesWithoutExtension, texts));\n  }\n\n  * names(dir) {\n    return Promise.resolve(yield readdir(dir));\n  }\n\n  * text(name) {\n    return Promise.resolve(yield readFile(path.join(this.input, name), 'utf8'));\n  }\n\n  * texts(names) {\n    return Promise.resolve(yield names.map(this.text.bind(this)));\n  }\n\n  * writePost(post) {\n    return Promise.resolve(yield appendFile(\n      path.join(this.output, post.name, `${post.name}.json`),\n      JSON.stringify(post)),\n    );\n  }\n\n  * writePosts(files) {\n    yield Promise.resolve(yield files.map(this.writePost.bind(this)));\n  }\n\n  * writeDir(dir) {\n    return Promise.resolve(yield mkdir(path.join(this.output, dir)));\n  }\n\n  * writeDirs(dirs) {\n    yield Promise.resolve(yield dirs.map(this.writeDir.bind(this)));\n  }\n\n  * clean() {\n    return Promise.resolve(rmrf(path.join(this.output, '*')));\n  }\n}\n```\n\nThere were two issues with this:\n1. Async/await handles the task in a nicer way. In fact, generators will work inside async/await in ES8.\n2. `main` function has unnecessary assignments hence holding unnecessary state. With the new functionality added later, the whole code became complicated - variables were shadowing each other and I had to come up with silly names to avoid this.\n\nSo, the next iteration had this ridiculous construct:\n```javascript\n    (yield (yield (yield (yield (yield (yield ((yield (yield this.readdir(this.input))\n        .filter(notASystemFile)\n        .map((dir) => p.join(this.input, dir))\n        .map(this.readdir))\n        .map(sortedPost)\n        .map(this.postWithText.bind(this))))\n        .map(this.createPostDir.bind(this)))\n        .map(this.createImageDirs.bind(this)))\n        .map(this.copyImage.bind(this))\n        .map(this.createPostFiles.bind(this)))\n        .map(this.createIndexFile.bind(this)))\n    );\n```\nRewriting it with async/await didn't make much difference - `yield` was replaced with `await` and that's it. It was much better in terms of internal state of the function, but those `yield` statements obviously had to go.\n\nToday, Converter looks like this:\n\n```javascript\nconst appendFile = promisify(fs.appendFile);\nconst mkdir = promisify(fs.mkdir);\nconst readdir = promisify(fs.readdir);\nconst readFile = promisify(fs.readFile);\nconst exists = promisify(fs.exists);\nconst rmrf = promisify(rimraf);\n\nconst id = shortid.generate;\nconst I = (identity) => identity;\nconst map = (fn) => (data) => data.map(fn);\nconst filter = (fn) => (data) => data.filter(fn);\nconst mapAsync = (fn) => (data) => Promise.all(data.map(fn));\n\nconst errHandler = (err) => {\n  // eslint-disable-next-line no-console\n  console.log(err.stack);\n  throw new Error(err);\n};\n\n\nconst HTMLTemplate = (postName, mountPoint) => (`\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n  <head>\n    <title>Representer</title>\n    <meta http-equiv=\"refresh\" content=\"0;URL='/${mountPoint}/?post=${postName}'\" />\n  </head>\n</html>\n`);\n\nconst title = (text) => text.split('\\n')[0].replace(/#\\s/, '');\nconst notASystemFile = (path) => path !== '.DS_Store';\nconst imageFile = (fileName) => fileName.match(/.jpg|.jpeg|.png/) ? fileName : false;\nconst mdFile = (fileName) => fileName.match(/.md/) ? fileName : false;\n\nconst postsWithContent = (postFolder) => ({\n  // [ [ 'img.png', 'post-1' ], [ 'post-2' ] ]\n  images: postFolder.map(imageFile).filter(I),\n  name: postFolder.map(mdFile).filter(I)[0].replace(/\\..*/, ''), // Remove extension.\n});\n\n\nclass Converter {\n  constructor(input, output, mountPoint = '', clean = false) {\n    this.input = input;\n    this.output = output;\n    this.clean = clean;\n    this.mountPoint = mountPoint;\n  }\n\n  convert() {\n    this.main().catch(errHandler);\n  }\n\n  async main() {\n    if (this.clean) await this.eraseOutputDir();\n    await this.createOutputDirs();\n\n    await this.readdir(this.input)\n      .then(filter(notASystemFile))\n      .then(map((dir) => p.join(this.input, dir)))\n      .then(mapAsync(this.readdir))\n      .then(map(postsWithContent))\n      .then(mapAsync(this.postWithText.bind(this)))\n      .then(mapAsync(this.createPostDir.bind(this)))\n      .then(mapAsync(this.createImageDirs.bind(this)))\n      .then(map(this.copyImage.bind(this)))\n      .then(mapAsync(this.createPostFiles.bind(this)))\n      .then((posts) => this.createIndexFile(posts));\n  }\n\n  async readdir(dir) {\n    return await readdir(dir); // eslint-disable-line no-return-await\n  }\n\n  copyImage(path) {\n    path.images.map((i) => fs.createReadStream(`${this.input}/${path.name}/${i}`)\n        .pipe(fs.createWriteStream(`${this.output}/posts/${path.name}/images/${i}`)));\n    return path;\n  }\n\n  async postWithText(post) {\n    return {\n      ...post,\n      ...{ text: await readFile(`${this.input}/${post.name}/${post.name}.md`, 'utf8') },\n    };\n  }\n\n  async createPostFiles(post) {\n    await appendFile(\n      p.join(this.output, 'posts', post.name, `${post.name}.json`),\n      JSON.stringify({\n        name: post.name,\n        text: post.text,\n        title: title(post.text),\n      }));\n\n    await appendFile(\n      p.join(this.output, 'posts', post.name, 'index.html'),\n      HTMLTemplate(post.name, this.mountPoint));\n\n    return post;\n  }\n\n  async createIndexFile(posts) {\n    await appendFile(\n      `${this.output}/index.json`,\n      JSON.stringify(\n        posts.map((post) => (\n          {\n            id: id(),\n            name: post.name,\n            title: title(post.text),\n          }\n        )),\n      ),\n    );\n    return posts;\n  }\n\n  async createDirInOutput(dir) {\n    // TODO: Recursive create.\n    const path = p.join(this.output, dir || '');\n    if (!(await exists(path))) await mkdir(path);\n    return dir;\n  }\n\n  async createImageDirs(post) {\n    await this.createDirInOutput(p.join('posts', post.name, 'images'));\n    return post;\n  }\n\n  async createPostDir(post) {\n    await this.createDirInOutput(p.join('posts', post.name));\n    return post;\n  }\n\n  async eraseOutputDir() {\n    await rmrf(p.join(this.output));\n  }\n\n  async createOutputDirs() {\n    await this.createDirInOutput();\n    await this.createDirInOutput('posts');\n  }\n```\n\n## Flow intervention\nExcuse me for the lack of documentation. You see, I don't really like JSDoc and similar documentation systems. Initially I started this project with Flow support, but `react-boilerplate` does not provide an easy drop-in solution, so I paused learning Flow in favor of other parts of the stack. Unfortunately, Upwork doesn't have a lot of jobs with Flow in description, so that wasn't a priority. Although it's hard to find such jobs considering Flow could also mean Git Flow or something else. There are jobs involving Typescript, but I believe Flow should work better, since the other crucial parts of the stack -  React and Jest - also came from Facebook.\n\nLet me explain how this relates to documentation. JSDoc adds too much noise to the code:\n```javascript\n/**\n * Post with transformed text.\n * @param {string} post\n * @param {string} text\n * @param {function} transform - function to transform with.\n * @returns {id: number, name: string, text: string}\n */\nconst withTransformedText = (post, text, transform) => (\n  { ...post, ...{ text: transform(text) } }\n);\n```\n\nWith Flow I get more information in a much more convenient form:\n```javascript\nconst withTransformedText = (post: Post, text: string, transform: function): Post => (\n  { ...post, ...{ text: transform(text) } }\n);\n```\n\nIt's not just I can instantly see what exactly function accepts and returns, I can also be sure that the function will accept and return only what the type annotation says. I can quickly preview both the Post type in a clear manner and the function itself when I call it. And I don't need JSDoc annotation, which can't be viewed in Quick Definition window.\n\n![quick definition](quick-definition.png)\n\n## Functional Javascript\nAs you could guess, I'm more of a functional guy. I used the `Class` statement to eliminate the necessity to write `function` keyword for async methods and to pass the context - options, input and output directories. Now I'm pretty sure I'd better off using closures or passing the context as parameters to particular functions, since context requires clumsy and somewhat confusing `bind(this)` in this current implementation.\n\nDuring the project development, few important functional concepts became intuitive: higher order functions, currying and composition. Nevertheless I have a long way to master functional programming, initial learning curve was passed and today I see a clear learning path. OO design always felt convoluted to me. Not only Design Patterns from Gang of Four, but even the concept itself. It is very vague.\n\nNow, coming back to Converter, basically it's job is to make side effects. It's not just computes and gives the result, but creates and copies directories and files. Perhaps, the most challenging task in programming is side effects management. Of course, on the scale of this particular project the job is very simple, but even in this case unexperienced programmer can create a horrifying procedural mess.\n\nLet's take a look at the main function:\n```javascript\nawait this.readdir(this.input)\n  .then(filter(notASystemFile))\n  .then(map((dir) => p.join(this.input, dir)))\n  .then(mapAsync(this.readdir))\n  .then(map(postsWithContent))\n  .then(mapAsync(this.postWithText.bind(this)))\n  .then(mapAsync(this.createPostDir.bind(this)))\n  .then(mapAsync(this.createImageDirs.bind(this)))\n  .then(map(this.copyImage.bind(this)))\n  .then(mapAsync(this.createPostFiles.bind(this)))\n  .then((posts) => this.createIndexFile(posts));\n```\n\nThis pipeline form separates intermediate state into distinct blocks with clear intents and eliminates the need of intermediate variables, making the code easy to read and reason about.\n\n`map`, `mapAsync` and `filter` functions are completely optional, but I decided to keep them. Perhaps, it is easier to read the code without them, since we can name the data being passed:\n```javascript\nawait this.readdir(this.input)\n  .then(filter(notASystemFile))\n  .then(posts => posts.map((dir) => p.join(this.input, dir)))\n  .then(posts => posts.mapAsync(this.readdir))\n  .then(posts => posts.map(postsWithContent))\n  .then(posts => posts.mapAsync(this.postWithText.bind(this)))\n  .then(posts => posts.mapAsync(this.createPostDir.bind(this)))\n  .then(posts => posts.mapAsync(this.createImageDirs.bind(this)))\n  .then(posts => posts.map(this.copyImage.bind(this)))\n  .then(posts => posts.mapAsync(this.createPostFiles.bind(this)))\n  .then(posts => posts.mapAsync(this.createIndexFile.bind(this)))\n```\n\nAnother important aspect of programming is naming things. When I started learning functional programming, I was concerned with performance - every function creates it's own scope hence affecting performance. In Ramda library, where every function is auto-curried, performance implications are huge:\n\n```javascript\nconst sum = (x, y) => x + y;\nconst sumCurried = x => y => x + y;\nconst ramdaCurried = R.curry(sum);\n```\n\n`no curry x 555,919,475 ops/sec ±0.56% (87 runs sampled)\narrow curry x 82,833,844 ops/sec ±1.19% (87 runs sampled)\nRamda curry x 2,721,681 ops/sec ±1.26% (88 runs sampled)`\n\nBut it doesn't matter that much since IO and DOM manipulations use most of the CPU time.\n\n## toNodeList\nThere are few moments in this module that might raise questions.\n\n```javascript\n// ...\nconst element = (m, fn) => (\n  {\n    type: 'jsx',\n    match: m.map(I),\n    jsx: fn,\n    index: m.index,\n    length: m[0].length,\n  }\n);\n\n// ...\nconst bold = (m) => <strong key={id()}>{m[1]}</strong>;\nconst code = (m) => <SyntaxHighLighter key={id()} language={m[1]} style={rshStyle}>{m[2]}</SyntaxHighLighter>;\nconst h1 = (m) => <h1 key={id()}>{m[2]}</h1>;\nconst h2 = (m) => <h2 key={id()}>{m[1]}</h2>;\n// ...\n\nconst id = shortid.generate;\nconst I = (identity) => identity;\nconst match = (text, m) => text.match(m[1]);\nconst matched = (text) => (m) => match(text, m) ? element(match(text, m), m[0]) : false;\nconst byIndexAsc = (a, b) => a.index - b.index;\nconst jsxs = (text, matchers) => matchers.map(matched(text));\n\nconst nextText = (text, fstJSX, sndJSX) =>\n  fstJSX ? { type: 'text', match: text.substring(0, fstJSX.index) }\n    : sndJSX ? { type: 'text', match: text.substring(0, sndJSX.index) }\n    : text.length > 0 ? { type: 'text', match: text }\n      : false;\n\nconst nextJSX = (text, jsx) => jsx && text.substring(0, jsx.index).length === 0 ? jsx : false;\n\nconst remainingText = (text, next) => {\n  switch (next.type) {\n    case 'jsx':\n      return text.substring(next.index + next.length, text.length);\n    case 'text':\n      return text.substring(next.match.length);\n    default:\n      return '';\n  }\n};\n\nconst toNodeList = (postName, text) => (rendered) => {\n  if (!text || text.length === 0) return rendered;\n\n  const matchers = [\n    [italic, /_(.*?)_/],\n    [bold, /\\*\\*(.*?)\\*\\*/],\n    // ...\n  ];\n\n  const sortedJSXs = jsxs(text, matchers)\n    .filter(I)\n    .sort(byIndexAsc);\n\n  const fstJSX = sortedJSXs[0];\n  const sndJSX = sortedJSXs[1];\n\n  const next = nextJSX(text, fstJSX) || nextText(text, fstJSX, sndJSX);\n  const convertWithRemaining = toNodeList(postName, remainingText(text, next));\n\n  return next.type === 'jsx' ?\n    convertWithRemaining(rendered.concat(nextJSX(text, next)))\n    :\n    convertWithRemaining(rendered.concat(nextText(text, false, fstJSX)));\n};\n\nexport default toNodeList;\n```\n**1**. Performance issues with `SyntaxHighLighter`. It performs some heavy manipulations and one easy way to keep feedback instantaneous is to turn the `code` matcher off in development environment.\n**2**. Speaking of performance, there is an example of currying usage I was thinking about:\n```javascript\nconst toNodeList = (postName, text) => (rendered) => { \n// ...\n  const convertWithRemaining = toNodeList(postName, remainingText(text, next));\n\n  return next.type === 'jsx' ?\n    convertWithRemaining(rendered.concat(nextJSX(text, next)))\n    :\n    convertWithRemaining(rendered.concat(nextText(text, false, fstJSX)));\n};\n```\nJust as unnecessary assignments, sometimes currying can be used solely to add readability. If I would have used all three parameters in this function, I wouldn't get this clear `convertWithRemaining` function. I think it's an appropriate compromise here.\n\n**3**. Usage of nested ternary operator, which is disliked by many of us and by Airbnb linter rules.\n```javascript\nconst nextText = (text, fstJSX, sndJSX) =>\n  fstJSX ? { type: 'text', match: text.substring(0, fstJSX.index) }\n    : sndJSX ? { type: 'text', match: text.substring(0, sndJSX.index) }\n    : text.length > 0 ? { type: 'text', match: text }\n      : false;\n```\nPersonally, I find it clearer than if/else blocks, but Webstorm gives this weird indentation that I can't change and it indents further right upon adding new statements. I rely heavily on auto-formatting feature, so it probably should be changed to regular if/else. Anyway, I'm against of linter rules customization - defaults looks good enough, and here I was merely experimenting with different styles.\n\n## Summary \nMost of the other code is written along the nice structure of boilerplate, so there isn't much to say. I'm glad I had time to start this project. There is a lot of work could be done and the most exiting about it is that any JS app can be naturally embedded into this project, provided with all the necessary tools, thanks to react-boilerplate.\n\nMarch 6, 2018\nVasily Tokarev\n","title":"Javascript in 2018"}